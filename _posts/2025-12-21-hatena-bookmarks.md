---
layout: post
title: "はてなブックマーク 2025年12月21日 の記事まとめ (7件)"
date: 2025-12-22 08:15:44 +0900
excerpt: "はてなブックマークで気になった記事をAIで要約してお届けします。2025年12月21日分の7件の記事をまとめました。

- イベントソーシングから学ぶ、削除をドメインの言葉で表現する設計

- LLM-as-a-Judge とルーブリック評価

- AI 駆動開発ライフサイクル(AI-DLC):ソフトウェアエンジニアリングの再構築 / AI-DLC Introduction

- GitHub Copilot Agent Skills 入門

- 個人の活動を記録する生成AI時代の日報「Activity Report」が生まれるまで｜hashiyaman

- チーム開発でcopilot-instructions.mdを導入してみたら、コードレビューの負担が減った

- 「継続」は力なり - 継続を知り、Promiseの限界を超え、Effect Systemへ - エムスリーテックブログ
"
---

はてなブックマークで気になった記事をAIで要約してお届けします。
2025年12月21日分の7件の記事をまとめました。

## 1. イベントソーシングから学ぶ、削除をドメインの言葉で表現する設計

**URL:** [https://zenn.dev/jtechjapan_pub/articles/c0673490bc548c](https://zenn.dev/jtechjapan_pub/articles/c0673490bc548c)

### AI要約

イベントソーシングでは、抽象的な「削除フラグ」の代わりに、ビジネスドメインに即した具体的な「状態変化イベント」として削除を表現する。
CQRSと組み合わせ、書き込み側（コマンドモデル）と読み込み側（リードモデル）で削除の扱いを分離設計する。
コマンドモデルでは、イベントによる集約の型変化で可能なアクションを制御し、ビジネスロジックの一貫性を高める。
リードモデルでは、イベントから目的に応じたビューを構築し、削除データの表示を柔軟に制御する。

---

この記事は、従来の「削除フラグ」がビジネス上の意味を曖昧にする課題に対し、イベントソーシングにおける「削除」の設計思想を解説しています。このアプローチでは、CQRS（コマンドクエリ責務分離）を前提とし、書き込み側（コマンドモデル）と読み込み側（リードモデル）で削除の設計を分離します。

コマンドモデルでは、ユーザーが「いなくなる」状況を単なる削除フラグではなく、支払い滞納による「アカウント無効化」やユーザー自身による「退会」、一時的な「休止」など、具体的なビジネスイベントとして記録します。これらのイベントは集約の「型」を変化させ、例えば「退会済み」の型になったユーザーには有料機能を使えない、といったように、システムが提供するアクションを型レベルで自動的に制限します。これにより、いちいち削除フラグをチェックする手間が省け、ビジネスロジックの堅牢性が向上します。

一方、リードモデルでは、コマンド側で記録されたイベントをもとに、目的に応じた複数のビューを柔軟に構成できます。例えば、全ユーザーリストでは退会者も表示し、アクティブユーザーリストでは非表示にするといった、要件に合わせたデータ表示の調整が可能です。このように、イベントソーシングはビジネスの文脈に深く根ざした、表現力豊かで一貫性の高いシステム構築を可能にします。

---

## 2. LLM-as-a-Judge とルーブリック評価

**URL:** [https://zenn.dev/ubie_dev/articles/llm-as-a-judge-rubric-evaluation](https://zenn.dev/ubie_dev/articles/llm-as-a-judge-rubric-evaluation)

### AI要約

**要点**
*   LLMの生成結果品質評価における「ルーブリック評価」の重要性を解説しています。
*   医療・健康分野で求められる高い正確性、安全性、定性的な価値の評価に活用されます。
*   LLMによる自動評価の課題である評価のブレを減らし、再現性と改善の実効性を高めることを目的としています。
*   電子レンジのトラブルシューティングを例に、従来の主観評価との比較を通じてその利点を説明します。

**詳細な要約**
Ubieでは、医療・健康に関するLLMを活用した相談アプリを開発・運用しており、生成される情報の品質評価が重要な課題となっています。特に、医療ドメインでは正確性や安全性に加え、"Helpfulness"（有用性）や "Empathy"（共感性）といった定性的な要素も高く求められます。

この記事では、LLMによる自動評価（LLM-as-a-Judge）の導入が進む一方で、その評価のブレや解釈の難しさといった課題に対し、「ルーブリック評価」が有効な解決策であることを提案しています。ルーブリック評価は、評価基準を明確にすることで、主観的な評価の揺らぎを抑制し、評価の再現性を向上させ、具体的な改善活動へと繋げやすくする実効性を持つと説明されています。

記事では、電子レンジのトラブルシューティングという身近な例を用いて、従来の1〜5点採点のような主観評価と比較しながら、ルーブリック評価がいかに優れているかを具体的に解説しています。これにより、LLMを活用したプロダクト開発において、信頼できる評価指標を確立し、品質改善サイクルを加速させることの重要性を強調しています。

---

## 3. AI 駆動開発ライフサイクル(AI-DLC):ソフトウェアエンジニアリングの再構築 / AI-DLC Introduction

**URL:** [https://speakerdeck.com/kanamasa/ai-dlc-introduction](https://speakerdeck.com/kanamasa/ai-dlc-introduction)

### AI要約

以下に、記事の要約を箇条書きと詳細な内容で示します。

**要点**
*   AI駆動開発ライフサイクル(AI-DLC)の導入を解説する資料です。
*   AI技術を活用し、ソフトウェアエンジニアリングの再構築を目指しています。
*   アマゾン ウェブ サービス ジャパン合同会社のソリューションアーキテクトによる講演資料です。

**詳細な要約**
本資料は、「AI 駆動開発ライフサイクル(AI-DLC):ソフトウェアエンジニアリングの再構築」と題された、AIがソフトウェア開発プロセスにもたらす変革の可能性を紹介する導入プレゼンテーションです。アマゾン ウェブ サービス ジャパン合同会社のソリューションアーキテクトである金森政雄氏が、2025年12月20日に開催されたイベントでこのコンセプトを提示しました。

AI-DLCの目的は、AI技術をソフトウェア開発ライフサイクル全体に統合することで、従来のエンジニアリング手法を根本から見直し、効率化と品質の向上を図ることです。要件定義から設計、開発、テスト、デプロイ、運用といった各フェーズでAIを活用し、プロセスの自動化や最適化を進めることで、ソフトウェア開発の生産性を飛躍的に高めることを目指しています。

この資料はAI-DLCの全体像を示す導入部分であり、AIがソフトウェアエンジニアリングをいかに再構築するかというテーマを提示しています。具体的なAIの活用方法や詳細な仕組みについては、この資料自体では深掘りされていませんが、今後のソフトウェア開発におけるAIの重要な役割と可能性を示唆するものです。

---

## 4. GitHub Copilot Agent Skills 入門

**URL:** [https://zenn.dev/openjny/articles/a9d4f6ec2a05c2](https://zenn.dev/openjny/articles/a9d4f6ec2a05c2)

### AI要約

### 要点

*   GitHub Copilotの「Agent Skills」は、プロジェクト固有の知識や特定のスクリプトの使い方を動的に読み込む新しい機能です。
*   これにより、従来のカスタム指示によるコンテキストウィンドウの圧迫を解消し、Copilotの能力を効率的に拡張できます。
*   Agent Skillsは、SKILL.mdファイルと関連ファイルで構成され、必要な時だけロードされる「専門知識のパッケージ」として機能します。
*   VS CodeでAgent Skillsを有効化するには設定が必要で、.github/skills/ディレクトリにスキルを配置するのが標準です。
*   システムプロンプトにスキルの存在と使用条件が動的に注入され、効率的な遅延ロードを実現します。

### 詳細な要約

GitHub Copilotの利用において、プロジェクト特有のルールやスクリプトの使い方といった情報をCopilotに覚えさせたい場面は少なくありませんでした。これまではカスタム指示やAGENTS.mdファイルで対応してきましたが、この記事では新たに導入された「Agent Skills」がこの課題に対する最適化された解決策として紹介されています。

Agent Skillsは、2025年12月18日にGitHub Copilotに追加された機能で、必要な時に動的にロードされる「専門知識のパッケージ」として機能します。これにより、Copilotはコンテキストを効率的に管理しながら、その能力を拡張できます。Agent Skillsは、AIエージェントに「専門知識」と「手続き的な知識」を与えるためのオープン標準であり、各スキルはSKILL.mdファイルとオプションの関連ファイルで構成されます。

この機能の最大の利点は、ドメイン専門知識の再利用、新しい能力の追加、反復可能なワークフローの実現、そして異なるエージェント製品間での相互運用性にあります。従来の常にプロンプトに含める方法とは異なり、スキルが必要な時だけ読み込まれるため、コンテキストウィンドウの圧迫を防ぎ、パフォーマンス向上に貢献します。

VS CodeでAgent Skillsを有効にするには、設定で`"chat.useAgentSkills": true`とし、スキルファイルは`.github/skills/`配下に配置するのが標準となります。記事では、入力されたテキストをそのまま返すシンプルな「echo-skill」の作成を通じて、SKILL.mdの仕様やYAMLフロントマターでの名前・説明の定義方法が説明されています。GitHub Copilotでスキルを利用するには、`read/readFile`ツールへのアクセスが必要です。また、Chat Debuglogを通じて、スキルが動的に読み込まれ、システムプロンプトにスキルの存在とその使用条件が注入されることで、効率的な遅延ロードが実現されていることが確認できます。

---

## 5. 個人の活動を記録する生成AI時代の日報「Activity Report」が生まれるまで｜hashiyaman

**URL:** [https://note.com/hashiyaman/n/n57ee6c67c416](https://note.com/hashiyaman/n/n57ee6c67c416)

### AI要約

**要点**
* Ubieは、個人の活動を自動で記録し、目標設定時の振り返りを効率化する生成AI日報「Activity Report」を開発。
* 初期段階では、AIによる事実誤認、情報過不足、データソース精度のばらつきといった課題に直面した。
* 課題解決のため、個人の担当領域に合わせた情報選別、データ特性に応じた処理方法の使い分け、ワークフローシステム「n8n」導入による開発効率化の三つの工夫を実施。
* 今後、会議の文字起こしやNotionデータの構造化を進め、AIが読みやすい「AI Readable」なデータ環境の整備を目指している。

**詳細な要約**
Ubieは、目標設定時の活動振り返り作業を効率化するため、個人の活動を自動で記録する生成AIを活用した日報「Activity Report」の開発を進めています。当初は社内生成AIプラットフォームを用いてJIRA、Notion、Slackなどから情報を収集しましたが、AIモデルの不安定さによる事実誤認やハルシネーション、業務に関係ないノイズの混入、特定の職種における情報不足、データソースごとの情報精度のばらつきといった多くの課題に直面しました。

これらの課題を解決するため、開発チームは大きく三つの工夫を導入しました。第一に、個人の担当業務（Epic）に紐づく情報をフィルタリングし、職種ごとのヒアリングに基づいて必要なデータソースを拡充しました。第二に、情報収集から分析までのフローを細分化。正確性が求められるデータ抽出・集計にはSQLやコードを、推測や解釈、要約など創造性が求められる処理には生成AIを組み合わせる多段階処理を採用し、出力の安定化を図りました。第三に、複雑なワークフローの開発・デバッグ効率を劇的に改善するため、ワークフローシステム「n8n」を導入。これにより、ソフトウェア開発のノウハウを適用し、複数人での協業やテストが容易になりました。

Ubieは今後、「Activity Report」の精度をさらに高めるため、源流となるデータそのものがAIにとって読みやすい形である「AI Readable」な世界の実現を目指しています。具体的には、オンライン会議の自動文字起こしと議事録化、そしてAIが解釈しやすいNotionデータベースの設計と構造化を全社的に推進し、生成AIのさらなる活用と「Activity Report」の進化を目指しています。

---

## 6. チーム開発でcopilot-instructions.mdを導入してみたら、コードレビューの負担が減った

**URL:** [https://zenn.dev/ren21/articles/bd27b78a515db5](https://zenn.dev/ren21/articles/bd27b78a515db5)

### AI要約

以下に記事の要約を示します。

### 要点

*   GitHub Copilotの`.github/copilot-instructions.md`を導入し、チーム開発におけるコード品質のばらつきとレビュー負担を軽減しました。
*   AIがプロジェクト固有のコーディング規約やベストプラクティスを学習し、適切なコード提案やチャット回答を行うようになります。
*   これにより、コードレビューが本質的な設計やロジックの議論に集中できるようになり、レビュー時間とコストが削減されました。
*   メンバーの理解度向上とチーム全体の生産性向上に繋がり、経験が浅いメンバーが多いチームに特に有効です。

### 詳細な要約

この記事では、Next.jsを用いたチーム開発において、GitHub Copilotの`.github/copilot-instructions.md`ファイルがコードレビューの負担を減らし、開発効率を向上させた事例を紹介しています。筆者のチームでは、メンバーの経験差やAI駆動開発によるコード品質のばらつき、レビューでの同じ指摘の繰り返しが課題でした。

この課題に対し、GitHub Copilotが自動的に読み込む`.github/copilot-instructions.md`に、Next.jsのベストプラクティスやプロジェクト特有のコーディング規約、エラーハンドリング、セキュリティチェックリストなどを記載しました。この設定により、Copilotはこれらのルールを学習し、開発時に「プロジェクトの正解」となるコードを自動で提案するようになりました。また、Copilot Chatで質問すると、プロジェクトの規約に沿った具体的な回答が即座に得られるようになり、ナレッジ共有の効率が大幅に向上しました。

最も顕著な効果はコードレビューの変化です。AIが基本的な規約違反や形式的な指摘を防いでくれるため、レビュアーは変数名やTry-Catchなどの詳細な部分ではなく、コードの設計やロジックの妥当性といった「本質的な内容」に集中できるようになりました。結果として、レビュー時間の削減、メンバーの理解度向上、基本的な規約違反の減少、そしてチーム全体の生産性向上が実現できたと筆者は述べています。この手法は、特に経験の浅いメンバーがいるチームや、コードの一貫性を高めたいチームに推奨されます。

---

## 7. 「継続」は力なり - 継続を知り、Promiseの限界を超え、Effect Systemへ - エムスリーテックブログ

**URL:** [https://www.m3tech.blog/entry/2025/12/14/100000](https://www.m3tech.blog/entry/2025/12/14/100000)

### AI要約

### 要点

*   「継続（Continuation）」とはプログラムの「残りの計算」を指し、特に非同期処理や副作用を伴う処理で重要となる。
*   コールバック関数は継続を明示化したものだが、複数階層になると「コールバック地獄」を引き起こし、可読性やエラー処理の漏れの問題がある。
*   Promiseやasync/awaitは継続の合成を可能にし、コールバック地獄を解消したが、エラーの型が不明瞭、エラー処理の漏れをコンパイル時に検知できない、リソース管理が手動という課題が残る。
*   Effect Systemはこれらの課題を解決し、エラー型を型シグネチャに含め、エラー処理の漏れをコンパイルエラーとして検知し、リソース管理を自動化することで、より堅牢な非同期処理を可能にする。

### 詳細な要約

この記事では、「継続（Continuation）」というプログラミングの概念を深く掘り下げ、JavaScriptにおける非同期処理の進化と課題、そしてそれを解決するEffect Systemについて解説しています。

まず、「継続」とはプログラムの各行の後に続く「残りの計算」を意味し、特にネットワーク通信やファイルI/Oなどの「副作用」を伴う非同期処理において、その後の処理が明示的な「継続」として意識されることを説明します。コールバック関数は、この継続を関数として表現したものですが、複数の非同期処理が連鎖すると、ネストが深くなり「コールバック地獄」という可読性の問題や、エラー処理の漏れといった課題が生じました。

この課題に対し、Promiseとasync/awaitが登場し、継続の合成を可能にすることでコールバック地獄を解消しました。しかし、これらの仕組みにも、エラーの型がシグネチャに現れないため、どのようなエラーが発生しうるか型から読み取れない点、エラー処理の漏れをコンパイル時に検知できない点、そしてリソース管理が手動になるという新たな課題が残りました。

そこで記事は、これらのPromiseの課題を解決する「Effect System」を紹介します。Effect Systemは、発生しうるエラーの型を型シグネチャに明示的に含めることで、どのようなエラーが起こりうるかを明確にします。また、エラー処理の漏れをコンパイルエラーとして検知し、未処理のエラーを防ぎます。さらに、リソースの取得と解放を自動化することで、リソースリークのリスクを低減します。具体例としてTypeScript向けライブラリ「Effect-TS」を挙げ、その実践的な利用法と、言語レベルでのEffect Systemの展望にも触れています。この技術は、より堅牢で保守性の高い非同期処理の実装を可能にすることを目的としています。

---

*この記事は、はてなブックマークのRSSフィードから自動生成されました。*  
*要約はAI（Gemini）によって生成されており、元記事の内容を正確に反映していない場合があります。*  
*詳細な内容については、各URLから元記事をご確認ください。*
